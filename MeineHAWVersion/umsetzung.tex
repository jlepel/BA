\chapter{Realisierung}
Dieses Kapitel wird die Umsetzung und die damit verbundene Realisierung des VM-Builders beschreiben. Die Umsetzung geschieht unter der Beachtung der zuvor durchgeführten Planung aus Kapitel \ref{ch:Anforderungsanalyse} und der damit verbundenen Integration von Dritt-Anwendungen. Ein wichtiger Aspekt des Kapitels ist die Verdeutlichung von Unterschieden, die zwischen Planung und der Umsetzung auftreten. Die Realisierung selbst wird in erster Linie ein Prototyp des VM-Builders anstreben, wobei auch seine Implementierung sich ganz nach dem Entwurf richtet, der in Kapitel \ref{ch:Entwurf} entstanden ist. Um die Anforderungen aus dem technischen Randbedingungen (Abschnitt \ref{subsec:TechnischeRandbedingungen}) zu erfüllen, geschieht die Umsetzung der Applikation in einer Kombination aus dem Framework Sinatra und Ruby und wird in der IDE 'RubyMine' entwickelt.\newline
Die Realisierung wird in drei Schritte unterteilt:
\begin{enumerate}
\item Aufbau des Servers (Abschnitt \ref{ssec:ServerRealisierung})
\item Installation und Beschreibung der Fremdsoftware (Abschnitt \ref{ssec:SoftwareRealisierung})
\item Erstellung und Implementierung des VM-Builders (Abhschnitt \ref{ssec:SoftwareRealisierung})
\end{enumerate}
Die drei Schritte beinhalten nicht nur Details zu ihrer Umsetzung, sondern auch die Unterschiede zum Entwurf.

\section{Server Realisierung}\label{ssec:ServerRealisierung}
Um die Vorraussetzungen für die Entwicklung des VM-Builders zu schaffen, wird der erste Schritt der Aufbauphase angegangen und eine Entwicklungsplatform vorbereitet. Anstelle eines Hardware-Servers, wird zunächst auf einer virtuelle Maschine entwickelt. Wie bereits in der Einleitung erwähnt, handelt es sich bei der Entwicklung um einen Prototypen der Applikation und genau auf diesem Aspekt aufbauend, ist eine virtuelle Umgebung zum entwickeln und testen mehr als geeignet.\newline
Zeitgleich wird eine identische Umgebung auf einem VM-Host der HAW aufgebaut, um später Unterschiede in der Aufbaugeschwindigkeit der virtuellen Maschinen messen zu können. Einfacherhalber wird in den folgenden Abschnitten lediglich ein Server betrachtet, damit keine Unklarheiten auftreten. Die Unterschiede der Server sind nur rein technischer Natur und unterscheiden sich weder in Applikationsversionen, noch im Aufbau.\newline
Der lokale virtuelle Server wird mit 4GB Arbeitsspreicher, 20 GB Festplattenkapazität und Ubuntu 14.04.2 umgesetzt. Der Server auf HAW-Seite, wird mit 16 GB Arbeitsspeicher ausgestattet und einem schnelleren Prozessor. Das Betriebssystem ist ebenfalls Ubuntu 14.04.2.

\section{Fremdsoftware}\label{ssec:SoftwareRealisierung}
Eines der Ergebnisse des Entwurfs war die Verwendung von Fremdsoftware, wodurch gewisse Teile des Funktionsspektrums übernommen werden sollen. Der zweite Schritt der Realisierung wird sich mit den einzelnen Softwareelementen beschäftigt, die für den Betrieb des VM-Builders eingesetzt werden sollen. In der Evaluation aus Kapitel \ref{ch:Evaluation} sind die ersten Annahmen getroffen worden welche Softwarekomponente sich für bestimmte Aufgabenbereiche eignen könnten, um sie dann in der in der Verteilungssicht (Abschnitt \ref{sec:Verteilungssicht}) provisorisch zu integrieren. Vorteile der verwendeten Applikationen sind ihre OpenSource Eigenschaften und der damit verbundene Verzicht auf weitere Kosten oder Investitionen. Die einzelnen Applikationen werden noch einmal kurz vorgestell, wobei auf Installationsdetails verzichtet wird.

\subsection{Webserver}
Für die Präsentation des Webinterfaces und für die Kommunikation zwischen Client und Server, wird auf den frei erhältlichen Apache Webserver, in der Version 2.4.7 zurückgegriffen.\newline
Es bietet sich an, einen etablierten Webserver zu nutzen, gerade wenn er den geforderten Open-Source-Aspekt erfüllt. Zudem besitzt Apache einen Marktanteil von 50,51\% an aktiven Webseiten (\cite{Statista:2015:Online}), wodurch das Argument der Etablierung weiter untermauert wird. Durch diesen Faktor kann zudem davon ausgegangen werden, dass die Weiterentwicklung weiter anhält, sowie Supportmöglichkeiten auch noch zukünftig vorhanden sein werden.

\subsection{Phusion Passenger}
Im Zuge der Vorbereitung auf die Appikation, wird auf Phusions Passenger zurückgegriffen, das als ein Modul für Apache konzipiert wurde. Phusions Passenger wird primär bei Ruby-Applikationen verwendet, um Ruby-Web-Applikationen bereitzustellen. Zudem erleichtert Passenger die Administration von Web-Applikationen und ist essenziel für den Betrieb des VM-Builders.\newline

\subsection{VirtualBox}
Ein eigener Entwurf und deren Ausführung einer Virtualisierungsstrategie, wäre weder zielführend noch praktikabel. Deshalb wurde in der Evaluation (Kapitel \ref{ssec:VirtualBox}) eine Analyse der frei zugänglichen Virtualisierer durchgeführt, wodurch letztendlich das Ergebnis VirtualBox als geeigneten Kandidaten herausstellte.
VirtualBox übernimmt beim VM-Builder die Funktion der Maschinenvirtualisierung und somit den automatisierten Aufbau der Umgebung.

\subsection{Ansible}
Damit die erstellte Umgebung mit Software bestückt werden kann, wird diese Aufgabe Ansible übertragen. Ansible kann die gewünschte Zustandsbeschreibung des Anwenders, direkt auf der virtuellen Maschine umsetzen, ohne dort einen extra Client installieren installieren zu müssen. Dies erleichtert nicht nur die Arbeit mit Ansible, sondern erleichtert zudem die Integration von Ansible in den VM-Builder. 

\subsection{Vagrant}
Vagrant dient als Wrapper für VirtualBox und Ansible. Die Flexibilität von Vagrant ermöglicht das leichte Zusammenspiel der drei Softwarekomponenten. Da Vagrant mit anderen Provisionierern und Virtualisierern zusammenarbeiten kann, ist ein Austausch von Ansible und VirtualBox in einem begrenzen Zeitrahmen möglich.\newline
Der VM-Builder wird über Befehlsaufrufe direkt mit Vagrant kommunizieren und durch entsprechende Befehle den Aufbau, die Deaktivierung, das Sharing usw. auslösen.

\subsection{Bundler}
Um in Ruby-Pojekten Abhängigkeiten zu genutzen Paketen zu verwalten und ggf. deren Versionen zu spezifizieren, kann auf Bundler zurückgegriffen werden.
Durch Bundler können einheitliche Umgebungen für Projekte geschaffen und der Wiederaufbau der gleichen Umgebung beschleunigt werden. Durch seine Eigenschaft, Ruby-Komponenten sofort und automatisch installieren zu können, ist Bundler prädestiniert für die Umsetzung einer automatisierte Installation des VM-Builders.

\subsection{Datenbank}
Um die objektorientierte Welt mit der Relationalen Welt der Datenbanken in Einklang zu bringen, können OR-Mapper helfen. Durch ihre Übersetzung von Quellcode, können programmatisch Tabellenkonstrukte erzeugt und Beziehungen zwischen den gewünschten Tabellen definiert werden. Datamapper ist eines der Beiden populärsten ORM Frameworks für Ruby und wird die beschriebenen Aufgaben im VM-Builder übernehmen.\newline
Ein Beispiel für die Funktionsweise von Datamapper, ist die Definition der Tabelle Machine, die aus vier Attributen besteht inklusive ihrer Typ-Eigenschaften, sowie ihrer Relation zu anderen Tabellen.
\begin{lstlisting} [caption={ORM Framework Datamapper},label={code:ORMTable}, language=Ruby]
class Machine
  include DataMapper::Resource

  property :id, Serial 
  property :name, String, :length => 255, :required => true 
  property :ip, String, :length => 15
  property :description, String, :length => 255
  property :status, Integer 

  has n, :files
  has n, :machinesoftwares
  has n, :softwares, :through => :machinesoftwares
  belongs_to :vmimage
end
 \end{lstlisting}
Programmatischer Zugriff auf die Tabellen kann über SQL-Befehle bereitgestellt werden, oder über typischerweise vorhandenen Befehle des ORM-Frameworks.
Um z.B aus der Tabelle \textbf{Machine} alle Daten einmal abzurufen genügt der Befehl 'Machine.all'. 
\begin{lstlisting} [caption={ORM Framework command},label={code:ORMCommand}, language=Ruby]
 def all_machines?
    Machine.all
  end
\end{lstlisting}

\section{Implementierung}\label{ssec:Implementierung}
Nach dem Aufbau der Server und der Installation der benötigten Softwarekomponenten, steht im nächsten Abschnitt die Implementierung des Protoypen im Vordergrund.
Ziel des Prototypen ist grundlegende Funktionen zu implementieren und zu testen, in wie weit sie durch die Anforderung realisierbar sind.\newline
Entsprechend stehen folgende Funktionalitäten im Mittelpunkt:
\begin{enumerate}
\item[\textbullet] Automatisierter Aufbau einer virtuellen Maschine 
\item[\textbullet] Provisionierung
\item[\textbullet] Speichern von VM-Konfigurationen
\item[\textbullet] Softwarebundles erstellen
\item[\textbullet] Virtuelle Maschine 'sharen'
\end{enumerate}
Zuvor wird ein Blick auf strukturellen Ansätze der Entwicklung geworfen, in dem allgemein auf die Komponenten-Umsetzung eingegangen wird und auf entsprechende Änderungen.
\subsection{Komponenten Umsetzung}
Wie bereits in der Einleitung des Kapitels erwähnt, wird der 'VM-Builder' mit Ruby inklusive dem Framework Sinatra umgesetzt. Um dem MVC-Konzept zu entsprechen, werden die definierten Komponenten aus \ref{ssec:Bausteinsicht} in der folgenden exemplarischen Ordner-/Dateistruktur (\ref{code:Filestructure}) umgesetzt.
\begin{lstlisting} [caption={Exemplarische Ordnerstruktur VM-Builder},label={code:Filestructure}, language=Ruby]
config.ru
app.rb
helpers/
  persistence_handler.rb
models/
  init.rb
routes/
  init_controller.rb
views/
  init_view.erb
\end{lstlisting}
Controller und Views aus der der Benutzerschnittstelle werden in den Ordnern 'routes' und 'views' erstellt. Bestandteile aus der Verarbeitungsebene und Datenebene werden in 'models' und 'helpers' gespeichert.\newline
Da Ruby/Sinatra zulässt auf Klassen zu verzichten, sind die Controller als organisatorische Einheit konzepiert mit der entsprechenden Logik in den verwendeten Modellen.
\begin{lstlisting} [caption={Controller Beispiel},label={code:ControllerExample}, language=Ruby]
require './models/administration_manager'
require_relative 'softwareadmin_controller'

get '/log' do
  @content = admin_mgr.log_content?
  erb :logfile
end

put '/log' do
  admin_mgr.update_log_config(params['logpath'])
  admin_mgr.create_logfile(params['logpath'])
  redirect '/admin'
end
\end{lstlisting}
Während die Views in HTML geschrieben und Helper, sowie Models als Ruby-Klassen definiert sind.\newline
Durch die Umsetzung haben sich Unterschiede bezüglich des Entwurfs herausgestellt, die folgende Bausteinsicht ergeben haben. 
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Bausteinsicht_Impl.png}
  \caption{Bausteinsicht Level 1}
	\label{fig:Bausteinsicht_MVC_Umsetzung}
\end{figure}
\FloatBarrier
Abgesehen von der Entstehung neuen Beziehungen zwischen Komponenten, ist eine der wesentlichen Änderungen das Wegfallen des ConfigurationfileHandlers. Seine Aufgabe bestand im Lesen und Beschreiben einer Konfigurationsdatei, die Konfigurationen des gesamten 'VM-Builders' beinhalten sollte. 
Anstelle der Konfigurationsdatei, werden die Konfigurationen in der Datenbank gepflegt.
Die daraus entstehenden Vorteile sind eine zentrale Steuerung für den persistenten Speicher und Änderungen, sowie das Hinzufügen von neuen Konfiguration sind deutlich vereinfacht worden.

\subsection{Datenbank}
Wie bereits erwähnt, wird im Gegensatz zur Planung, ein Tabellenkonstrukt angewendet, um Konfigurationen zu persistieren. Dies spart zu erstellende Komponenten und zentralisiert den Zugriff und die Datenhaltung.
Zur Umsetzung von Konfigurationstabellen werden in der Regel zwei Konzepte vorgeschlagen:
\begin{enumerate}

\item \textbf{Name-Value-Pair Table}\newline
Name-Value Pair Tabellen bestehen nur aus zwei Spalten. Eine für den Konfigurations-Typen und die Andere für den zugehörigen Wert. Kommen neue Konfigurationen dazu, werden die einfach an die Tabelle angehangen.
\begin{lstlisting} [caption={Name-Value-Pair Table},label={code:Name-Value-PairTable}]
  ConfigOption   |   Value
-----------------+-------------
 CompanyName     | ACME Inc.
 StartFullScreen | true (or 1, or Y, ...)
 RefreshSeconds  | 20
 ...             | ...
\end{lstlisting}


\textbf{Vorteil}
\begin{enumerate}

\item Neue Konfigurationen benötigen keine Rekonfiguration des Tabellenschemas
\item Schlanke Tabellenstruktur. Neue Konfigurationen werden einfach angehangen\newline
\end{enumerate}

\textbf{Nachteil}
\begin{enumerate}
\item Jede Konfiguration hat den gleichen Typ
\item Alles wird als String/Varchar gespeichert
\item Für die Arbeit mit den Werten der Konfigurationstabelle, sollte bekannt sein, welcher Typ sich eigentlich hinter dem Wert verbirgt
\end{enumerate}

\item \textbf{Single-Row Table}\newline
Bei Single-Row Tabellen wird die Struktur gedreht. Jede Konfiguration besteht aus einer eigenen Spalte. Die darunter liegende Zeile beinhaltet die Werte.
\begin{lstlisting} [caption={Single-Row Table},label={code:Single-RowTable}]

CompanyName | StartFullScreen | RefreshSeconds | ...
------------+-----------------+----------------+-----
  ACME Inc. |      true       |       20       |  ...
\end{lstlisting}

\textbf{Vorteil}
\begin{enumerate}
\item Jede Spalte hat bekommt den entsprechenden Datentyp
\item Durch den exakt angegebenen Typ jeder Spalte, kann in der Programmierung besser mit den Werten umgegangen werden
\item Jeder Spalte können leichter Standardwerte zugeordnet werden\newline
\end{enumerate}

\textbf{Nachteil}
\begin{enumerate}
\item Das Tabellenschema muss geändert werden, wenn neue Einstellungen hinzugefügt werden
\item Die Tabelle kann schnell unleserlich werden, wenn zu viele Einstellungen in der Tabelle enthalten sind
\end{enumerate}
\end{enumerate}
In der Umsetzung wurde das Konzept der '\textbf{Name-Value-Pair Table}' verwendet.
Auch wenn dieses Konzept weniger Vorteile als '\textbf{Single-Row}', spricht das leichtere Einpflegen von neuen Konfigurationseigenschaften und die bessere Lesbarkeit, für das Konzept.

\subsection{Funktionen}
Die Realisierung aller geplanten Controller, Models und Views hat das Funktionsspektrum der Applikation fast vollständig erfüllt.\newline
So sind folgende Funktionen durch die bisherige Implementierung realisiert worden:
\begin{description}
\item \textbf{Erstellung einer virtuellen Maschine} \\
Die Komponente 'Main-Representation', die die zentrale Steuerung darstellt, kommuniziert kann die BuildingProcess-Komponente aufrufen in der die Darstellung für den geleiteten Aufbau einer virtuellen Maschine gehalten wird und die Schnittstelle zu der entsprechenden Logik. Der Aufbauprozess beinhaltet die Benamung der gewünschten Maschine, Optionen wie IP-Adresse und die Auswahl an Softwarekomonenten. Echtzeitinformation über den Aufbauprozess sind nicht implementiert. Allerdings im Logfile nachlesbar.
VagrantControl liefert in Kombination mit dem SystemFileManager die Befehle für den Aufbau einer Maschine. Der SystemfFileManager bietet eine Methode für direkte Systemaufufe an, mit der VagrantControl Vagrant Befehle absetzen kann.
\item \textbf{Provisioning} \\
Die Provisionierung wurde in den Aufbau mit integriert und wird durch die Komponente MachineConstruction realisiert. Um genauer zu sein, durch die Klasse 'YamlBuilder'.
Die ausgewählte Software, wird durch diese Klasse in eine YAML-Datei übersetzt und mit Einstellungen aus der Konfigurations-Tabelle angereichert.
Beinhaltet die Auswahl an Software Unterkomponenten und/oder Dateien, die auf den Zielhost übertragen werden sollen, wird die YAML-Datei automatisch entsprechend angepasst.

\item \textbf{VM-Konfigurationen speichern} \\
Sobald eine virtuelle Maschine erfolgreich aufgebaut wurde, Name und optionale Einstellungen der Maschine, sowie ausgewählten Softwarekomponenten durch Transaktionen im Datamapper gespeichert. Durch die verwendeten Transaktionen, wird vermieden, dass inkonsistente Konfigurationen gespeichert werden und sichergestellt, dass diese auch nur im Erfolgsfall gesichert werden.\newline
Solange die Maschine durch keinen Anwender gelöscht wird, bleiben die gespeicherten Parameter bestehen.

\item \textbf{Softwarebundles erstellen} \\
Softwarebundles helfen dabei, Software mit Abhängigkeiten zu anderen Softwarekomponenten und Dateien zu erstellen und im System zu hinterlegen.
So wird die Möglichkeit geschaffen, Software zu installieren, die mehrere Installationsschritte benötigt.
Die SystemAdministration-Komponente hält dafür die entsprechende Implementierung vor. Da die Implementierung organisatorisch zur Administration gehört, wurde sie in diesem Paket platziert. Auch hier wird die Speicherung der Einstellungen durch Transaktionen bewerkstelligt, um keine Inkonsistenzen zu verursachen. Dem Anwender wird die Möglichkeit geboten, durch seine Eingaben zu entscheiden, was für eine Software gespeichert wird. Wählt er keine Relationen zu anderen Softwarekomponenten aus und lässt er die Möglichkeit aus Dateien zu transferieren, wird automatisch nur eine standard Software zur Auswahl hinzugefügt. Erst durch die Auswahl von Relationen und/oder Dateien, wird es ein Softwarebundle. Die Umsetzung der Auswahl geschieht in dem Model 'SoftwareEditor' der seine Entscheidung an den 'PersistenceHandler' weitergibt.

\item \textbf{VM-Sharing} \\
Das 'Sharing' einer bestehende virtuellen Maschine wird durch die interne Implementierung von Vagrant übernommen. Die Zuständigkeit um die Funktion in den 'VM-Builder' zu übernehmen und auszulösen, übernimmt die Klasse 'VagrantControl'. Wie auch bei dem Aufbau einer virtuellen Maschine, verwendet 'VagrantControl' die Funktion des 'SystemfileManagers' um den entsprechenden Befehl abzusetzen und an Vagrant selber weiterzuleiten. Das Teilen oder 'Sharing' einer virtuellen Maschine wird allerdings durch die Portsperrung des jeweiligen Netzwerkes eingeschränkt. Ist der Port 4567 gesperrt, wird durch Vagrant eine Fehlernachricht generiert und das Teilen der Maschine nicht ausgeführt. Bei erfolgreichem 'Sharing' wird ein SSH-Share erstellt. Die SSH Variante hat den Vorteil, dass Port und ggf. Passwort optional eingerichtet werden können, durch Angaben von erweiterten Parametern.
\end{description}


