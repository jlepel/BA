\setcounter{secnumdepth}{3}
\chapter{Softwareentwurf}\label{ch:Entwurf}
Nach \cite{Balzert201109} ist der Softwareentwurf die Entwicklung einer software-technischen Lösung im Sinne einer Softwarearchitektur auf Basis der gegebenen Anforderungen an ein Softwareprodukt. 
Die Herausforderung bei der Erstellung eines Softwareentwurfs ist eine Softwarearchitektur zu entwerfen, die die zuvor erarbeiteten funktionalen- (Kapitel \ref{sec:FunktionaleAnforderungen}) und nichtfunktionalen Anforderungen (Kapitel \ref{sec:NFA}) berücksichtigt, einschließlich der Berücksichtigung von Einflussfaktoren, wie definierte Randbedingungen (Kapitel \ref{sec:Randbedingungen}).
Der Softwareentwurf ist eine Richtlinie, die bei der Umsetzung der geforderten Software unterstützt.
Die zu erstellende Softwarearchitektur hingegen beschreibt Architekturbausteine, deren Interaktionen und Beziehungen untereinander sowie ggf. deren Verteilung auf physischer Ebene. Dabei ist die Spezifizierung der entsprechenden Schnittstellen der einzelnen Architekturbausteine mit zu beachten. Zur Visualisierung können verschiedene Abstufungen von Sichten verwendet werden, die Kontextabgrenzung, Bausteinsicht, Laufzeitsicht und die Verteilungssicht. Diese Sichten werden im folgenden Softwareentwurf verwendet und näher beschrieben.
\begin{comment}
\begin{enumerate}
\item \textbf{Kontextabgrenzung}
%Die Kontextabgrenzung beschreibt die Einbettung des Systems in seine Umgebung 
%sowie die wesentlichen Teile der umgebenden Infrastruktur.
\item \textbf{Bausteinsicht}
%Die Kontextabgrenzung beschreibt die Einbettung des Systems in seine Umgebung sowie die wesentlichen Teiler der umgebenden Infrastruktur.
\item \textbf{Laufzeitsicht}
\item \textbf{Verteilungssicht}
\end{enumerate}
\end{comment}
\begin{figure}[htbp]
  \centering
  \fbox{
\includegraphics[width=0.9\textwidth]{../Bilder/sichten.png}
  }
  \caption[Vier Arten von Sichten]{Vier Arten von Sichten\footnotemark}
	\label{fig:Sichten}
\end{figure}\footnotetext{Bildquelle: \cite{Starke201401}}  
\FloatBarrier

\section{Kontextabgrenzung}\label{sec:Kontextabgrenzung}
Die Kontextabgrenzung beschreibt die Einbettung des Systems in dessen Umgebung sowie die wesentlichen Teile der umgebenden Infrastruktur.
Die ermittelten Anforderungen aus Kapitel \ref{sec:FunktionaleAnforderungen} und \ref{sec:NFA} haben ergeben, dass die Hauptfunktionalitäten aus Erstellen, Exportieren, Importieren, Teilen und dem Provisioning von virtuellen Maschinen bestehen.
Um dieses weiter zu bündeln, können Teile der Hauptfunktionalitäten einzelner Produkte, die in Kapitel \ref{ch:Evaluation} betrachtet wurden, übernommen werden.
VirtualBox kann das Erstellen, Exportieren und den Import von virtuellen Maschinen übernehmen. Das Konfigurationsmanagement-System Ansible ist darauf ausgelegt, mit bekannten Virtualisierungslösungen zusammenarbeiten zu können und übernimmt somit die Anforderung nach automatisierter Softwareinstallation. 
Um die beiden Anwendungen zu kombinieren, kann Vagrant als Wrapper eingesetzt werden, der zusätzliche Funktionen, wie das Teilen (Sharen) einer Maschine, mitbringt.
Logik und Oberfläche werden durch den VM-Builder bereitgestellt, der in den folgenden Abschnitten näher konzipiert wird.
\begin{center}
 \begin{minipage}{\linewidth}
	\centering
	\includegraphics[scale=0.5]{../Bilder/kontextsicht.png}
	\captionof{figure}[Kontextsicht]{Kontextsicht\footnotemark}
	\label{fig:kontextsicht}
 \end{minipage}\footnotetext{Bildquelle: Eigene Darstellung}
\end{center}

\subsection{Kurzbeschreibung der externen Schnittstellen}\label{ssec:ExternSchnittstellen}
\begin{tabular}{p{4cm} p{10cm}}
\textbf{Eingaben / Auswahl} & Der Anwender tätigt Eingaben und wählt unter bereitgestellten Optionen aus. Diese werden direkt von der Applikation verarbeitet.\\
 &  \\
\textbf{Befehle und Konfigurationen} & Die Applikation erstellt nötige Konfigurationsdateien für Vagrant und Ansible und leitet Befehle für die Weiterverarbeitung an Vagrant weiter.\\
 &  \\
\textbf{Kommunikation über Konfigurationsdateien} & Vagrant ruft über die erstellten Konfigurationsdateien den Konfigurationsmanager Ansible auf, um die virtuelle Maschine in den beschriebenen Zustand zu überführen.\\
 &  \\
 \textbf{Vagrant interne\newline Abläufe} & VirtualBox erstellt dieses virtuelle Maschine und gibt Statusmeldungen an Vagrant weiter. Dies sind interne Abläufe, die zwischen Vagrant und VirtualBox ablaufen und nicht vom Entwicklungsprozess beeinflusst werden können. \\
 &
\end{tabular}
Die Applikation, inklusive der oben genannten Produkte, wird auf einem Server betrieben, der zentralisiert positioniert ist und über HTTP, FTP und SSH erreichbar ist.
Dem Anwender wird von der Applikation eine Weboberfläche zur Verfügung gestellt, die es ermöglicht Eingaben zu tätigen und Optionen auszuwählen, um eine virtuelle Maschine zu erstellen oder zu verwalten.
Damit die Applikation auf dem Server betrieben werden kann, muss eine Internetverbindung bestehen, die es Vagrant ermöglicht das gewünschte Abbild des Betriebssystems herunterzuladen und die virtuelle Maschine mit anderen Anwendern zu teilen.
Die vom Anwender gestellten Anfragen an den VM-Builder werden in Konfigurationsdateien übersetzt, die speziell für Vagrant und Ansible erstellt werden.
Diese Konfigurationsdateien dienen nicht nur zur Erstellung der gewünschten virtuellen Maschine, sondern auch zur Kommunikation zwischen Vagrant und Ansible.
Vagrant entnimmt den Konfigurationen das ausgewählte Image und leitet den dazugehörigen Download des Betriebssystems ein. Ist das Image auf dem Server schon vorhanden, wird dieses verwendet. Durch die Hilfe von VirtualBox und ggf. Ansible wird die zu erwartende virtuelle Maschine komplettiert.
 
\section{Verteilungssicht}\label{sec:Verteilungssicht}
Um die Beschreibung aus \ref{ssec:ExternSchnittstellen} der Kontextabgrenzung visuell zu unterstützen, wird die Verteilungssicht herangezogen.
\cite{Hruschka201103} beschreibt die Verteilungssicht dabei wie folgt:
\begin{quote}
"Die Verteilungssicht zeigt die Verteilung von Systembestandteilen auf Hard- und Softwareumgebungen. Diese Sicht klärt, welche Teile des Systems auf welchen Rechnern, an welchen geographischen Standorten oder in welchen Umgebungen ablaufen können, wenn es in einer konkreten technischen Infrastruktur installiert wird."\newline
\end{quote}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Verteilungssicht.png}
  \caption[Verteilungssicht des VM-Builders]{Verteilungssicht des VM-Builders\footnotemark}
	\label{fig:Verteilungssicht}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}  
\FloatBarrier 
\noindent
Die genaue Platzierung der Softwarekomponenten aus Abschnitt \ref{ssec:ExternSchnittstellen} verhilft zu einer besseren Umsetzung der kompletten Softwarestruktur und verdeutlicht die Beziehung zwischen den einzelnen Komponenten. Unter den Abschnitten \ref{sssec:TechnologischeAnforderungen} und \ref{subsec:TechnischeRandbedingungen} wurden technologische Anforderungen und entsprechende Randbedingungen beschrieben und definiert. Die dortige Beschreibung definiert, dass die zu verwendende Software frei verfügbar und kostenlos sein muss. 
Aus diesem Grund wird bei dem Betrieb des Servers Ubuntu verwendet, wobei hier die aktuelle Version (Stand Juni 2015) vorausgesetzt wird. Als Webserver kann Apache eingesetzt werden, der mittels dem zustandslosen HTTP-Protokoll mit dem Client kommuniziert.
Die benötigte rationale Datenbank kann durch MySQL umgesetzt werden. Diese wird primär für das Speichern von Konfigurationen einzelner virtueller Maschinen genutzt, dem speichern derer individuellen Konfigurationen und zur Persistierung der angebotenen Softwarekomponenten.
In dem Execution-Framwork wird der VM-Builder ausgeführt, der wiederum an die Drittanbieter Ansible und Vagrant angebunden ist.

\section{Bausteinsicht}\label{sec:BausteinsichtErklaerung}
\cite{Hruschka201103} beschreibt in seinem Werk die Bausteinsicht wie folgt:
\begin{quote}
"Sie zeigt die statische Struktur des Systems, seinen Aufbau aus Softwarebausteinen sowie deren Beziehungen und Schnittstellen untereinander. Jeder dieser Bausteine
wird letztlich durch eine Menge (selbst erstelltem oder zugekauftem) Quellcode implementiert."
\end{quote}
Ausgehend vom Systemkontext wird das System hierarchisch zergliedert. Somit entstehen Ebenen in unterschiedlichem Detailgrad. Ebene 0 stellt das System als Blackbox dar, die der Kontextsicht aus Abbildung \ref{fig:kontextsicht} entspricht.
In den höheren Ebenen wird der Detailgrad erhöht und die dargestellte Blackbox zur Whitebox. Eine Whitebox gibt einen detaillierten Einblicke in dessen Struktur und Schnittstellen, die wiederum als Blackboxen dargestellt werden.\\
Die Bausteinsicht wird in die Planung des VM-Builders mit einbezogen und in Abschnitt \ref{ssec:Bausteinsicht} zur Darstellung der Komponentenstruktur verwendet.

\section{Laufzeitsicht}\label{sec:Laufzeitsicht}
Nach \cite{Starke201205} zeigt die Laufzeitsicht Elemente der Bausteinsicht in Aktion, veranschaulicht dynamische Strukturen und das Verhalten des Systems.
Laufzeitsichten helfen zudem Verantwortlichkeiten zu klären und Schnittstellen zwischen Komponenten zu definieren. [\cite{Starke201205}]. Durch die Erstellung von konkreten Szenarien, lassen sich Namen und Parameter für Operationen ableiten und vereinfachen das Verständnis der zukünftigen Implementierung. Abschnitt \ref{ssec:Laufzeitsicht} zeigt die Anwendung der Laufzeitsicht auf ein primäres Szenario des VM-Builders.

\section{Systemarchitektur}\label{sec:Systemarchitektur}
Nachdem die Umsysteme, deren Verteilung und der technische Aufbau des VM-Builders konzipiert sind, wird die Struktur der eigentlichen Anwendung geplant werden. Dafür gibt es etablierte Architektur- und Entwurfsmuster, auf die zurückgegriffen werden kann.
Diese helfen bei der Verteilung der Verantwortlichkeiten und bilden eine Vorlage für die Systemstrukturen. Da diese sich in einigen Punkten überschneiden und ergänzen, entstehen bei der Verwendung mehrerer Architekturmuster keine Widersprüche.

\subsection{Client-Server-Modell}\label{subsec:ClientServer}
Um eine möglichst gute strukturelle Verteilung der Aufgaben und Dienstleistungen des VM-Builders auf physikalischer Ebene zu erhalten, wird auf das Client-Server-Modell zurückgegriffen.
Durch das Client-Server-Modell wird die Aufgabenverteilung innerhalb einer Applikation strukturiert sowie die Zentralisierung von Prozessorenleistung und gemeinsamen Diensten. [\cite{Schaefer200912}]\newline
Die eindeutige Unterscheidung zwischen den Client- und Servertätigkeiten kann durch einen geschichteten Architekturstil erreicht werden, der die Aufgaben in folgende Schichten unterteilt:
\begin{enumerate}
\item Benutzerschnittstelle (User interface)\newline
Die Benutzerschnittstelle enthält alles Erforderliche, um direkt mit dem Anwender zu interagieren.
\item Verarbeitungsebene (Application)\newline
Die Verarbeitungsebene enthält die Anwendung / Kernfunktionalität.
\item Datenebene (Database)\newline
Daten werden unabhängig von der Applikation persistent gespeichert.
\end{enumerate}
Im Zusammenhang mit dem Client-Server-Modell steht das n-Tier Model oder auch als Schichtenmodell bezeichnet. Eine Schicht ist entweder ein physikalischer Rechner oder mindestens ein Systemprozess, der eine bestimmte Aufgabe übernimmt. Die einfachste Anordnung dieser Schichten besteht darin, diese auf zwei Computer, den Client und den Server, zu verteilen (2-Tier Model)\footnotemark. Dabei können die Schichten wie in Abbildung \ref{fig:Client-Server-Anordnungen} auf der folgenden Seite dargestellt, zwischen Client und Server verteilt sein. [\cite{TanenbaumSteen200711}]
\begin{figure}[htbp]
  \centering
  \fbox{
\includegraphics[width=0.9\textwidth]{../Bilder/client-server-anordnungen.png}
  }
  \caption[Client-Server-Anordnungen]{Client-Server-Anordnungen\footnotemark}
	\label{fig:Client-Server-Anordnungen}
\end{figure}\footnotetext{Bildquelle: \cite{TanenbaumSteen200711}}  
\FloatBarrier
\noindent
Die in Abbildung \ref{fig:Client-Server-Anordnungen} (a) bis (c) dargestellten Varianten gehören zu der Kategorie Thin-Clients, während die Varianten (d) und (e) zu den sogenannte Fat-Clients gezählt werden. Das Konzept des VM-Builders wird eines der Thin-Client-Konstrukte verwenden, um die Client-Seite zu planen.\newline 
Einer der Vorteile von Thin-Clients ist, dass weniger bis keine Client-Software auf die Seite des Anwenders gebracht werden muss. Die Problematik, die bei der Verwendung von Software auf Clientseite entsteht, ist die schwerere Administration des Clients und dessen höhere Anfälligkeit für Fehler. [\cite{TanenbaumSteen200711}]\newline
Die, im Rahmen dieser Arbeit, angestrebte Client-Server-Anordnung ist die in Abbildung \ref{fig:Client-Server-Anordnungen} (a) gezeigte Variante. Der Client soll so minimal wie möglich gehalten werden, um dem Anwender einen schnellen Seitenaufbau zu ermöglichen und lokale Installationen zu vermindern. So liegt die Kontrolle der Darstellung auf Applikations-Seite.
Da in der Anforderungsanalyse Kapitel \ref{subsec:TechnischeRandbedingungen} festgelegt wurde, dass mit Ruby inkl. des Frameworks Sinatra gearbeitet werden soll, wird die Logik auf der Server-Seite implementiert und benötigt keinen Anteil auf Client-Seite. Entsprechend sind die Verarbeitungs- (Application) und die Datenebene (Database) auf der Server-Seite angesiedelt.
Auf Verarbeitungsebene wird der Webserver mit den Applikationskomponenten des VM-Builders realisiert. Die Datenebene spiegelt die zu verwendende Datenbank wider, die für die Persistierung von Daten zuständig sein wird.\\
Beim Client-Server-Aufbau mit Variante (b) wird davon ausgegangen, dass die gesamte Darstellung auf Client-Seite platziert wird, wodurch eine Separierung vom Client zur restlichen Anwendung vollzogen wird. Die Anwendung von Variante (c) wird in Applikationen verwendet, in denen zusätzlich Logikverarbeitung auf Anwender-Seite ausgeführt werden soll, wogegen die Planung des VM-Builders sprechen würde. So ist die Wahl von Variante (a) als Thin-Client am praktikabelsten.

\subsection{Model-View-Controller Entwurfsmuster}\label{subsec:MVC}
Für eine strukturierte Umsetzung der grafischen Komponente des VM-Builders wird auf das bekannte architektonische Model-View-Controller-Entwufsmuster zurückgegriffen.
Das Model-View-Controller-Entwurfsmuster (auch MVC genannt) findet beim Entwurf grafischer Benutzungsoberfläche anwendung, d.h. bei Mensch-Maschine-Interaktionen.
Dazu wird das System, das Interaktionen anbietet und ausführt, in drei Verantwortlichkeiten unterteilt:
\begin{enumerate}
\item \textbf{Model}\newline
Kapselt alle fachlichen Daten und enthält den Anwendungskern.
\item \textbf{View}\newline
Bereitet Informationen für den Anwender grafisch auf.
\item \textbf{Controller}\newline
Nehmen Benutzereingaben/Events an, die entsprechend an das passende Model oder die View weitergeleitet werden.
\end{enumerate}
Wie das Client-Server-Model besteht auch das Model-View-Controller-Entwurfsmuster aus drei Schichten. Anstatt diese drei Schichten auf mehrere physikalische oder virtuelle Systeme zu verteilen, werden diese auf Applikationsebene abgebildet. Das MVC-Entwurfsmuster kann zwar auf jeder der Schichten des Client-Server-Models implementiert werden, hat aber im Gegensatz zu dem Client-Server-Model nichts mit der Verteilung des Systems zu tun.

\begin{figure}[htbp]
  \centering
  \fbox{
\includegraphics[width=0.4\textwidth]{../Bilder/MVC-Process_Wiki.png}
  }
  \caption[Model-View-Controller]{Model-View-Controller\footnotemark}
	\label{fig:MVC}
\end{figure}\footnotetext{Bildquelle: \cite{Wikipedia:2015:Online}}  
\FloatBarrier
Abbildung \ref{fig:MVC} zeigt die Kommunikation zwischen den Bestandteilen des Model-View-Controller-Entwurfsmusters.

\begin{enumerate}
\item Alle Eingaben/Änderungen des \textbf{User} werden von der Benutzeroberfäche an den Controller weitergegeben.
\item Der \textbf{Controller} gibt Zustandsänderungen an das Model weiter.
\item Das \textbf{Model} verarbeitet die erhaltenden Daten, in dem diese z.B. an den persistenten Speicher weitergeleitet werden oder Berechnungen stattfinden.
\item Die resultierenden Ergebnisse / Änderungen werden über die View sichtbar gemacht.
\end{enumerate}
Das MVC-Entwurfsmuster entkoppelt das User-Interface von der Verarbeitungsebene. Es trennt die View (Repräsentation) und das Model (Fachlichkeiten) von einander, da die Änderungshäufigkeit beider Ebenen unterschiedlich ausfallen können.
Durchschnittlich ändern sich z.B. Windows-Oberflächen etwa alle zwei Jahre, Fachlichkeit ca. 10 bis 15 Jahren.
Das MVC-Entwurfsmuster ermöglicht als eine Modernisierungsmaßnahme den Austausch der Oberfläche, ohne die Fachlichkeiten ändern zu müssen.
[\cite{Masak200911}]\\
Da das geforderte Framework Sinatra dieses Konzept nativ umsetzen kann, lässt sich das Entwurfsmuster einfach in der Programmierung anwenden. In Sinatra werden die Views separiert von den sogenannten Routen (Controllern) implementiert, wodurch die 'V'- und 'C'- Eigenschaften erfüllt werden. Um die Modell-Anforderungen zu erfüllen, kann z.B. ein Datenbank-Framework, wie Active-Record, angewendet werden. 
Die Abbildung \ref{fig:MVC_eigen} zeigt die Integration des MVC-Entwurfsmusters in das Schichtenmodell.
\begin{figure}[htbp]
  \centering
  \fbox{
\includegraphics[width=0.9\textwidth]{../Bilder/MVC_Eigen.png}
  }
  \caption[Model-View-Controller im 3-Schichten-Modell]{Model-View-Controller im 3-Schichten-Modell\footnotemark}
	\label{fig:MVC_eigen}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}  
\FloatBarrier
\noindent
Da der Client nur für die Darstellung zuständig ist wird wie in Abbildung  \ref{fig:MVC_eigen} zu sehen das MVC-Entwurfsmuster nur auf Server-Seite implementiert. Entsprechend werden die Controller und die Views im serverseitigen Teil der Benutzerschnittstelle implementiert, während die Modells sich über die Verarbeitungsebene und Datenebene erstrecken, um den Zugriff auf die Datenhaltung zu gewährleisten.

\section{Kommunikation}\label{sec:Kommunikation}
Die Kommunikation zwischen Client und Server wird über das zustandslose HTTP Protokoll realisiert. Wird von einem Client (der theoretisch ein Web-Browser, eine Web-Anwendung, ein Dienst usw. sein kann) aus eine Webserver-Kommunikation aufgebaut, erstellt der Client dabei eine HTTP-Nachricht. Diese Nachricht ist in 'plain-text' geschrieben und 'zeilenorientiert'. Dadurch ist eine Nachricht einfach zu erstellen und auf Serverseite einfach auszuwerten. Ist die Anfragebearbeitung auf Serverseite abgeschlossen, sendet dieser in der Regel den Status (Client-Anforderung erfolgreich, Fehler, etc.), Inhalte und andere Daten zurück an den Client. Nachrichten enthalten sogenannte HTTP-Verben, die den Typ der Anfrage definieren und wie der Server die Anfrage zu bearbeiten hat. [\cite{HarrisHaase201112}].\newline\newline
\begin{tabular}{p{5cm} p{8cm}}
\textbf{Standard HTTP-Verben} & \textbf{Definition} \\
GET &  Eine GET-Anforderung wird verwendet, um einen Server zu bitten, die Darstellung einer Ressource zurückzuliefern.\newline \\
POST &  Eine POST-Anforderung wird verwendet, um Daten an einen Webserver zu übermitteln.\newline \\
PUT & PUT wird verwendet, um auf einem Server eine Ressource zu erstellen oder zu aktualisieren.\newline \\
DELETE & DELETE wird verwendet, um eine Ressource auf dem Server zu löschen.\\
 & 
\end{tabular}
\noindent
In dem zu verwendenden Framework Sinatra wird das Vokabular der HTTP-Verben benutzt, um Routen zu definieren. Um eine Route in Sinatra zu deklarieren, wird das HTTP-Verb in Verbindung mit der URL benötigt. Das Verhalten der Route wird im Anschluss definiert und beim Aufruf der Route ausgeführt, siehe Abbildung: \ref{code:SinatraVerbs}.\newline
 \begin{lstlisting} [caption={Routen in Sinatra\protect\footnotemark},label={code:SinatraVerbs}, language=Ruby]
get '/' do
  .. zeige etwas ..
end

post '/' do
  .. erstelle etwas ..
end

put '/' do
  .. update etwas ..
end

delete '/' do
  .. entferne etwas ..
end

options '/' do
  .. zeige, was wir können ..
end

link '/' do
  .. verbinde etwas ..
end

unlink '/' do
  .. trenne etwas ..
end
 \end{lstlisting}\footnotetext{Quelle: \cite{Sinatra:2015:Online}}
 

\section{Server}\label{sec:Server}
Im Folgenden wird die strukturelle Planung des Servers erstellt und geschieht unter der Verwendung der Entwurfsmuster aus Abschnitt \ref{sec:Systemarchitektur}. Damit ein vollständiges Bild des Server-Konstrukts entsteht, werden im Folgenden unter anderem die Bausteinsicht und die Laufzeitsicht aus der Abbildung \ref{fig:Sichten} konstruiert.

\subsection{Bausteinsicht}\label{ssec:Bausteinsicht}
Wie bereits in Abschnitt \ref{sec:BausteinsichtErklaerung} erklärt, zeigt die Bausteinsicht die Struktur des Systems und schafft eine Übersicht über die geplanten Komponenten. Abbildung \ref{fig:Bausteinsicht_MVC} ist eine Ebene-1-Darstellung der Serverapplikation in Form des MVC-Entwurfsmusters. In dieser Darstellung wird der VM-Builder mit seinen einzelnen Komponenten betrachtet, die als Blackboxen dargestellt sind. 
\begin{figure}[htb]
  \centering
\includegraphics[width=1.1\textwidth]{../Bilder/Bausteinsicht.png}
  \caption[Bausteinsicht Level 1]{Bausteinsicht Level 1\footnotemark}
	\label{fig:Bausteinsicht_MVC}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}  
\FloatBarrier
\noindent
Die Komponenten sind in deren Zuständigkeiten gegliedert und den entsprechenden Schichten zugeordnet. Die Schnittstellen werden durch Interaktionspunkte zwischen den Schichten dargestellt. Jede Komponente enthält, der jeweiligen Schicht entsprechend, Controller, Views und/oder Models, die in dem folgenden Abschnitt detaillierter betrachtet werden.
\pagebreak
\subsubsection{Benutzerschnittstelle}\label{sssec:Benutzerschnittstelle}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Benutzerschnittstelle.png}
  \caption[Benutzerschnittstelle]{Benutzerschnittstelle\footnotemark}
	\label{fig:Benutzerschnittstelle}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}  
\FloatBarrier
\noindent
Der für die Kommunikation zuständige Anwendungsteil ist die Benutzerschnittstelle (siehe Abbildung \ref{fig:Benutzerschnittstelle}). Die dort enthaltenen Komponenten sind für die Annehme der User-Interaktionen zuständig und für die Darstellung der gewünschten Inhalte. 

\subsubsection*{Distributor-Komponente}\label{sssec:Distributor}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Distributor.png}
  \caption[Komponentensicht Distributor]{Komponentensicht Distributor\footnotemark}
	\label{fig:Komponentensicht Distributor}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}  
\FloatBarrier
\noindent	
Die primäre Aufgabe der Distributor-Komponente liegt im Empfang der eingehenden Kommunikation und der Weiterleitung an den entsprechenden Controller.
Durch den Einsatz dieser Komponente werden die Hauptfunktionalitäten in eine eindeutige Hierarchie unterteilt. Da die Administration des VM-Builders eine andere Hauptfunktion ist als der Aufbau und die Verwaltung von virtuellen Maschinen, werden diese in der Komponente getrennt. So erleichtert der Aufbau der Komponente
eine Erweiterung an neuen primären Funktionen.
So wird das Hinzufügen von neuen Hauptfunktionalitäten, durch den Aufbau der Komponente, einfacher.
\noindent
\subsubsection*{MainRepresentation-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/MainRepresentation.png}
  \caption[Komponentensicht MainRepresentation]{Komponentensicht MainRepresentation\footnotemark}
	\label{fig:Komponentensicht VMBuilder}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier	
\noindent	
Im Inneren der MainRepresentation-Komponente ist der MainController platziert, der mit Hilfe der InitView eine Übersicht der bestehenden virtuellen Maschinen bereitstellt. Die Übersicht wird durch Daten aus der VMRepresentator-Komponente generiert, die in der Verarbeitungsebene implementiert ist. Aus dieser Ansicht kann zudem der Aufbauprozess einer neuen Maschine initialisiert werden, der über die BuildingProcess-Komponente gesteuert wird. Die MachineOption-Komponente steuert die eingehenden Optionen virtuelle Maschinen und leitet diese an den zuständigen Controller weiter.
\pagebreak
\subsubsection*{BuildingProcess-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/BuildingProcess.png}
  \caption[Komponentensicht BuildingProcess]{Komponentensicht BuildingProcess\footnotemark}
	\label{fig:BuildingProcess}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent	
Der Aufbauprozess einer virtuellen Maschine wird grafisch durch die BuildingProcess-Komponente bereitgehalten. Die dort enthaltenen Views leiten den Anwender durch den Aufbauprozess. Dabei beinhaltet jede View einen Konfigurationsschritt:
\begin{enumerate}
\item SetupView\newline
In der SetupView werden die Eigenschaften wie IP-Adresse und Name der zu erstellenden Maschine festgelegt
\item SoftwareSelectionView\newline
Um die virtuelle Maschine in den gewünschten Zustand zu versetzen, bietet die SoftwareSelectionView dem Anwender eine Auswahl an zu installierenden Softwarekomponenten und Paketen.
\item StatusView\newline
Die StatusView erstellt eine Übersicht über den aktuellen Aufbauverlauf und präsentiert die Zugangsmöglichkeiten zur virtuellen Maschine.
\end{enumerate}
Unterstützt wird der Aufbau durch den Zugriff auf die MachineConstruction-Komponente der Verarbeitungsebene. Dieser gibt unter anderem der SoftwareSelectionView eine Vorgabe an Auswahloptionen, die der Anwender in verwenden kann.
Da der Aufbau einer virtuellen Maschine erst durch einen definierten Aufruf aus der MainRepresentation erfolgen soll, ist der BuildingProcessController auch nur über diese Komponente aufrufbar.

\subsubsection*{MachineOption-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/MachineOption.png}
  \caption[Komponentensicht MachineOption]{Komponentensicht MachineOption\footnotemark}
	\label{fig:MachineOption}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent	
In Abbildung \ref{fig:MachineOption} ist ersichtlich, dass die MachineOption-Komponente drei Views bereitstellt, die alle über den Controller indirekt in Beziehung zueinander stehen. Diese repräsentieren die Optionen, die ein Anwender auf eine bestehende Maschine ausführen kann. Über die Schnittstelle der MachineManagement-Komponente, werden die einzelnen Funktionalitäten bereitgestellt und ausgeführt. 

\subsubsection*{Administration-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/administration.png}
  \caption[Komponentensicht Administration]{Komponentensicht Administration\footnotemark}
	\label{fig:administration}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent	
Wie bereits in Abschnitt Distributor-Komponente (\ref{sssec:Distributor}) beschrieben, wird neben der MainRepresentation-Komponente auch die Administration-Komponente realisiert. Diese ist für die Visualisierung der generellen Einstellungen und der Anzeige von Logdateien. Die Schnittstelle der Administration-Komponente ist mit der SystemAdministration-Komponente aus der Verarbeitungsebene verbunden, um die voreingestellten Anwendungseinstellungen abzurufen und Änderungen an diesen speichern zu können.
%Organisatorisch ist die Software-Komponente mit der Administration-Komponente verknüpft. Die Software-Komponente beinhaltet die Controler Verwaltung von Software Softwareeditor ist als eigenständige Komponente angeschlossen, der spezielle Funktionen bereitstellt.

\subsubsection*{Software-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Software.png}
  \caption[Komponentensicht Software]{Komponentensicht Software\footnotemark}
	\label{fig:SoftwareSelection}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent	
Die an der Administration-Komponente angeschlossene Software-Komponente 
unterstützt den Anwender in der Konfiguration einzelner Softwarekomponenten und Software-Pakete. Pakete bestehen aus einzelnen Softwarekomponenten, die zueinander in Abhängigkeit gestellt werden. So können beim Aufbau einer virtuellen Maschine durch die Auswahl eines Paketes mehrere Softwarekomponenten automatisiert installiert werden. Zudem ermöglicht die Software-Komponente neue Softwarekomponenten hinzuzufügen, zu bearbeiten und zu ändern. Entsprechende Views helfen dem Anwender die ausgewählten Funktionen durchzuführen.\\
Organisatorisch gehört die Software-Komponente zur Administration-Komponente. Dieses ermöglicht eine einfachere Implementierung einer Benutzerverwaltung, falls zukünftig Änderungen an Einstellungen und Softwarekomponenten nur von einem bestimmten Personenkreis durchgeführt werden sollen.
\pagebreak

\subsubsection{Verarbeitungseben}\label{sssec:Verarbeitungsebene}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Verarbeitungsebene.png}
  \caption[Ansicht der Verarbeitungsebene]{Ansicht der Verarbeitungsebene\footnotemark}
	\label{fig:Verarbeitungsebene}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
Wie im MVC-Entwurfsmuster vorgesehen, beinhaltet die Verarbeitungsebene die Logik der Anwendung, die durch logisch konstruierte Komponenten repräsentiert wird.
Da Komponenten wiederum aus Komponenten bestehen können, werden diese durch eine Whitebox-Darstellung explizit hervorgehoben. Die Komponenten, die für sich selber stehen, kommen ohne weitere Whitebox-Darstellung aus.
\pagebreak
\subsubsection*{MachineConstruction-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/MachineConstruction.png}
  \caption[Komponentenansicht MachineConstruction]{Komponentenansicht MachineConstruction\footnotemark}
	\label{fig:MachineConstruction}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
Der Aufbau einer virtuellen Maschine wird durch die MachineConstruction-Komponente realisiert. Die dort enthaltende Buildprocessor-Komponente enthält die Logik, die den Aufbau der virtuellen Maschinen steuert, in dem diese auf Komponenten der Verarbeitungs- und Datenebene zugreift. Durch die PersistenceHandler-Komponente können die Attribute der virtuellen Maschine in der Datenbank gespeichert und für die Verwaltung der virtuellen Maschinen wieder ausgelesen werden.
Um die vom Anwender ausgewählten Softwarekomponenten zu verarbeiten, ist die Verwendung der Provisioner-Komponente nötig. Diese erzeugt aus der Softwareauswahl eine Provisionierungsdatei, die bei der Erstellung der virtuellen Maschine einbezogen wird. Damit die Provisionierungsdatei und alle folgenden Dateien im richtigen Verzeichnis abgelegt werden, wird durch den SystemFileManager eine definierte Verzeichnisstruktur erstellt. In dieser werden alle Konfigurationsdateien der virtuellen Maschine sowie hochgeladenen Dateien des Anwenders gespeichert. Ein Bestandteil der gerade erwähnten Konfigurationsdateien ist das Vagrantfile. Das Vagrantfile beinhaltet alle wichtigen Konfigurationseinstellungen der zu erstellenden virtuellen Maschine. Die Erstellung dieser Datei erfolgt aus vorgegebenen- und anwenderabhängigen Informationen und wird durch die VagrantControl-Komponente durchgeführt. Zudem stellt diese Komponente dem Buildprocessor alle Steuerbefehle für Vagrant zur Verfügung. Über den Zugriff auf die ConfigurationfileHandler-Komponente, die sich in der Datenebene befinden, erhalten der Buildprocessor, VagrantControl und die Provisioner-Komponente Grundkonfigurationseinstellungen, die für den Aufbau und die Erstellung der einzelnen Dateien benötigt werden.

\subsection{Provisioner-Komponente}
Die Provisioner-Komponente ist ein erweiterter Bestandteil des Aufbauprozesses. 
Durch die Verwendung dieser Komponente, wird eine YAML-Datei erzeugt, falls der Anwender eine Softwareauswahl getroffen hat. Die YAML-Datei ist optional, da diese lediglich benötigt wird, wenn Software auf einer virtuellen Maschine installiert werden soll. Wurde keine Software vom Anwender ausgewählt, wird die Konfiguration des Maschinen-Aufbaus so angepasst, dass der Provisionierer nicht involviert wird. 
Die Provisioner-Komponente baut aus den Informationen, die sie aus dem BuildProcessor erhält, die richtige Struktur und den inhaltlichen Kontext der YAML-Datei auf. Ergänzt werden diese Informationen durch Daten aus dem ConfigurationFileHandler, der sich in der Datenebene befindet. Dieser übergibt weitere Grundkonfigurationen an die Provisionier-Komponente, um den Aufbau der Datei zu vervollständigen.

\subsubsection*{VagrantControl-Komponente}
VagrantControl vereinigt Befehlsaufrufe für die Steuerung von Vagrant. Zudem extrahiert die Komponente wichtige Informationen aus den Statusinformationen von Vagrant heraus, die bei der Ausführung von Vagrant erzeugt werden. Die Informationen werden interpretiert und in Rückgabewerte von Funktionsaufrufen umgewandelt. Zudem werden diese für die Generierung von Fehlermeldungen benötigt und verwendet. Da Vagrant nur mit einem gültigen Vagrantfile lauffähig ist, übernimmt VagrantControl auch das Erstellen dieser.
\pagebreak

\subsubsection*{SystemAdministration-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/SystemAdministration.png}
  \caption[Komponentenansicht SystemAdministration]{Komponentenansicht SystemAdministration\footnotemark}
	\label{fig:SystemAdministration}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
Die Umsetzung der Logik der administrativen Ansicht geschieht durch die AdministrationManager-Komponente, die in der SystemAdministration implementiert ist. Der dort verwendete ConfigurationfileHandler liest alle notwendigen Einstellung aus der Konfigurationsdatei des VM-Builders heraus und stellt diese zur Verfügung. Entsprechend können Änderungen an diesen übergeben und in der Konfigurationsdatei ersetzt werden. Eine weitere Eigenschaft der AdministrationManager-Komponente ist das Bereitstellen des Inhalts der Applikationslogdatei. Durch entsprechende Funktionsimplementierungen im SystemFileManager werden Inhalte von Dateien ausgelesen und zurückgegeben. So kann die SystemAdministration-Komponente der Administration-Komponente aus der Benutzerschnittelle alle wichtigen Daten zur Darstellung liefern. 
\pagebreak
\subsection{SoftwareAdministration-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/SoftwareAdministration.png}	
  \caption[Komponentenansicht SoftwareAdministration]{Komponentenansicht SoftwareAdministration\footnotemark}
	\label{fig:SoftwareAdministration}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
Für die Verwaltung und Bereitstellung von Softwarekomponenten und Softwarepaketen stellt der VM-Builder eine Administrative-Oberfläche bereit. Die Umsetzung der dort angebotenen Optionen erfolgt in der SoftwareAdministration-Komponente, durch die Komponenten SoftwareManager und PackageManager. Jede der beiden Komponenten beinhaltet Funktionen zum Bearbeiten, Löschen oder Hinzufügen von Software- oder Packageelementen. Der PackageManager erweitert den Funktionsumfang zudem um das hochladen von eigenen Dateien, um Packages weiter zu individualisieren. Die Speicherung der jeweiligen Aktionen des Anwenders wird durch die Verwendung des PersistanceHandler durchgeführt.  
\pagebreak

\subsubsection*{MachineManagement-Komponente}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/MachineManagement.png}	
  \caption[Komponentenansicht MachineManagement]{Komponentenansicht MachineManagement\footnotemark}
	\label{fig:Machinemanagement}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
Um dem Anwender Optionen für die bereits bestehenden virtuellen Maschinen anbieten zu können, wird der MachineManager verwendet. Dieser ist eine Verwaltungskomponente für Optionen, die auf virtuelle Maschinen ausgeführt werden können.
Wie in Abbildung \ref{fig:Verarbeitungsebene} dargestellt, werden Optionen wie Export-, Import- und das Sharing von Maschinen angeboten, die durch Hinzufügen weiterer Komponenten erweitert werden können.
Die MachineSharing-Komponente bereitet eine virtuelle Maschine so vor, dass auf diese von internen- und externen Netzwerken aus zugegriffen werden kann. Beschränkungen auf den Zugriff können allerdings durch Richtlinien des Netzwerkes entstehen, indem der VM-Builder ausgeführt wird. Zudem ist der MachineExporter in der Lage eine virtuelle Maschine zu exportieren, indem dieser Konfigurationsdateien packt und dem Anwender zur Verfügung stellt. Diese Dateien können in anderer Virtualisierungsprodukte geladen werden oder durch den MachineImporter wieder in die Anwendung importiert werden. 
Durch die Hinzunahme des Buildprocessor können die importierten Dateien zur automatisierten Erstellung des Wiederaufbaus verwendet werden.

\subsubsection*{VMRepresentator-Komponente}
Die VMRepresentator-Komponenten ist der Informationslieferant für die MainRepresentation-Komponente aus der Benutzerschnittstelle. Durch diese Komponente werden die verwalteten virtuellen Maschinen der Web-Repräsentation übergeben.

\subsubsection*{SystemFileManager-Komponente}
Die Zugriffsverwaltung auf das Dateisystem wird durch den SystemFileManagers ermöglicht. Durch diese Komponente werden Standard-Ordner-Funktionen des Betriebssystems ermöglicht. Beispielsweise Kopier-, Duplizierungs- und Erstellungsoperationen. Zudem bietet dieser eine Funktion zum Aufruf von Systembefehlen an, damit Linux-Befehle vom VM-Builder ausgeführt werden können.
\pagebreak
\subsubsection{Datenebene}\label{sssec:Dateneben}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Datenebene.png}
  \caption[Ansicht der Datenebene]{Ansicht der Datenebene\footnotemark}
	\label{fig:Datenebene}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
In der Datenschicht werden Funktionen verankert, die zum direkten Lesen aus dem Datenspeicher verwendet werden. Dieses können beispielsweise Funktionen sein, die mittels SQL-Abfragen auf die Datenbank zugreifen oder die lesenden- und/oder schreibenden Zugriff auf Dateien ermöglichen.

\subsubsection*{PersistanceHandler-Komponente}
Der PersistanceHandler ist einer der beiden Komponenten in der Datenebene.
Durch die dort definierte Funktionen werden kontrollierte Zugriffe auf die Datenhaltung ermöglicht. Die Manipulation der Daten soll ausschließlich durch diese Komponente erfolgen. Der PersistenceHandler wird somit zur Schnittstelle zwischen Applikation und Datenbank.

\subsubsection*{ConfigurationfileHandler-Komponente}
Ebenfalls in der Datenebene implementiert ist der ConfigurationfileHandler.
Durch diese Komponente werden Grundeinstellungen aus einer Konfigurationsdatei gelesen und nötigenfalls zurückgespeichert. 
Die Grundeinstellungen enthalten allgemeine Applikationseinstellungen, Einstellungen für Vagrant und Konfigurationen für Ansible. Der ConfigurationfileHandler extrahiert diese drei Einstellungstypen und bereitet diese für den entsprechenden Anwendungszweck auf.
So kann z.B. die Provisioner-Komponente ihre benötigten Informationen aus dem ConfigurationfileHandler beziehen.
\pagebreak

\subsection{Laufzeitsicht}\label{ssec:Laufzeitsicht}
Wie in Abschnitt \ref{sec:Laufzeitsicht} beschrieben, können in der Laufzeitsicht Abhängigkeiten und Schnittstellen zwischen Komponenten veranschaulicht werden.
Die Abbildung \ref{fig:LaufzeitsichtVMAufbau} nimmt exemplarisch einen interessanten Aspekt des VM-Builders heraus und bildet diesen in der Darstellung der Laufzeitsicht ab.
Die dort verwendeten Funktionsaufrufe sind eine Abstraktion der späteren Implementierung, da im Entwurf unabhängig von Programmiersprachen gearbeitet sowie auf implementierungsdetails verzichtet wird.

\subsubsection{Aufbau einer virtuellen Maschine}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/Laufzeitsicht_VMAufbau.png}
  \caption[Laufzeitsicht eines VM-Aufbaus]{Laufzeitsicht eines VM-Aufbaus\footnotemark}
	\label{fig:LaufzeitsichtVMAufbau}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
Der Aufbau einer virtuellen Maschine ist eines der prägnanten Leistungsmerkmale der hier zu entwerfenden Software.\\ 
Das Sequenzdiagramm aus Abbildung \ref{fig:LaufzeitsichtVMAufbau} beschreibt den Vorgang des Aufbaus einer virtuellen Maschine, in dem die Kommunikation zwischen den beteiligten Komponenten detaillierter aufgezeigt wird. Als Ausgangssituation wird der Usecase \ref{sssec:UseCase1} verwendet, der den Aufbau einer virtuellen Maschine beschreibt. \newline\newline

\subsubsection*{Ausgangssituation}
\begin{itemize}
\item \textbf{Der Anwender möchte eine virtuelle Maschine erstellen.}
\end{itemize}
\subsubsection*{Beschreibung}
\begin{enumerate}
\item[1. ] Der Anwender öffnet im Webbrowser den VM-Builder, navigiert zu der Webseite, die die Erstellung von virtuellen Maschinen beinhaltet. Dort wählt der Anwender Attribute der Maschine und zu installierende Software aus. Zusätzlich lädt der Anwender eine Datei hoch und drückt auf den Speichern-Knopf. Danach wird dem Anwender eine Statusseite angezeigt, die ihm den aktuellen Aufbaustand präsentiert. Die Webseite, die den Aufbau der virtuellen Maschinen steuert und die Statusseite werden von Controllern der BuildingProcess-Komponente gehalten.
\item[2. ] Der Controller, der die Aufbauseite verwaltet, sendet nach der Ausführung des Speichern-Knopfs alle Daten an die MachineConstruction-Komponente. Diese Daten beinhalten alle Eingaben des Anwenders, die Softwareauswahl und Informationen der hochzuladenen Dateien.
\item[3. ] Die MachineConstruction-Komponente benötigt zum abspeichern der Daten den PersistenceHandler, der entsprechende Funktionen zum speichern der Konfigurationen bereitstellt.
\item[4. ] Nach der Speicherung der Daten übergibt der PersistenceHandler eine Erfolgsmeldung an die MachineConstruction-Komponente.
\item[5. ] Diese verwendet die erhaltene Rückmeldung um auf der Statusseite den aktuellen Aufbaustand der virtuellen Maschine zu aktualisieren.
\item[6. ] Im nächsten Aufbauschritt wird die Dateistruktur für die virtuelle Maschine erstellt. Um diese erstellen zu können, wird auf den SystemfileManager, der Dateisystemfunktionen bereitstellt, zurückgegriffen.
\item[7. ] Ist die Ordnerstruktur angelegt worden, wird dieses durch eine Rückmeldung des SystemfileManagers an die MachineConstruction quittiert.
\item[8. ] Diese Meldung wird dann auf der Statuswebseite verarbeitet und dem Anwender gezeigt.
\item[9. ] Durch die Auswahl an Softwarekomponenten, muss eine Provisioningdatei erzeugt werden, die durch den Aufruf der Provisioner-Komponente konstruiert wird.
\item[10. ] Nach der Erzeugung der Datei und ihrer Speicherung im Verzeichnis der Maschine, gibt die Provisioner-Komponente eine Statusmeldung an die MachineConstruction zurück.
\item[11. ] Auch diese Statusmeldung wird verwendet um den aktuellen Status des Aufbaus zu aktualisieren.
\item[12. ] Um den Aufbau der virtuellen Maschine zu ermöglichen, muss die primäre Konfigurationsdatei, das Vagrantfile, geschrieben werden. Dies geschieht über die Implementierung in der VagrantControl-Komponente. 
\item[13. ] Nach der Erstellung des Vagrantfiles gibt diese Komponente eine Statusrückmeldung zurück.
\item[14. ] Diese Rückmeldung wird von der MachineConstruction-Komponente weiterverarbeitet und auf der Statusseite angezeigt.
\item[15. ] Da der Anwender eine Datei hochladen möchte, wird diese auf den Server geladen. Jede hochgeladene Datei wird im Verzeichnis der jeweiligen virtuellen Maschine gespeichert. Zum hochladen bietet der SystemfileManager eine Funktion an, die eine beliebige Anzahl an Datei in das ausgewählte Zielverzeichnis lädt.
\item[16. ] Generierte Rückmeldungen des SystemfileManagers werden an die MachineConstruction weitergegeben.
\item[17. ] Diese verwendet die Rückmeldungen um den Status des Aufbaus zu erneuern.
\item[18. ] Im letzten Aufbauschritt, wird der eigentliche Aufbauprozess initialisiert und VagrantControl erneut angesprochen um den initialen Prozess in Vagrant anzustoßen
\item[19. ] Die durch Vagrant erzeugten Statusmeldungen, werden aufbereitet und zurückgeliefert.
\item[20. ] Die Statusmeldungen werden auf der Statusseite aufbereitet und zeigen dem Anwender den aktuellen Aufbaustatus an. Nach dem erfolgreichem Aufbau wechselt die Anwendung wieder auf die Hauptseite.
\end{enumerate}
\pagebreak
%\subsubsection{Verwendung von Optionen einer virtuellen Maschine}

\subsection{Datenbank}\label{ssec:Datenbank}
Wie in der Verteilungssicht (Abbildung \ref{fig:Verteilungssicht}) beschrieben, wird der Server eine relationale Datenbank bereithalten. Der Zuständigkeitsbereich der Datenbank liegt im Speichern von virtuellen Maschinen, deren Konfigurationen und der Verwaltung von Softwarebestandteilen. Optionen bezüglich des Verhaltens von Dateien werden zusätzlich in einer separaten Tabelle abgelegt. 
Für den Entwurf der Datenbank werden zwei Notationsformen verwendet. Abschnitt \ref{sssec:ERM} zeigt in der Notation des Entity-Relationship-Model den ersten konzeptionellen Entwurf des Datenmodells, während Abschnitt \ref{sssec:RelationalDatabaseModel} die tabellarische Umsetzung des Konzeptes abbildet.

\subsubsection{Entity-Relationship-Model}\label{sssec:ERM}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/datamodel_impl.png}
  \caption[Entity-Relationship-Model]{Entity-Relationship-Model\footnotemark}
	\label{fig:Entity-Relationship-Model}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
\noindent
Die in der Abbildung \ref{fig:Entity-Relationship-Model} dargestellte Konzipierung, zeigt das semantische Konstrukt der angestrebte Datanbank, wobei die folgende Beschreibung die Bedeutung und die Abhängigkeiten des Modells erklärt.
Die Tabelle Machine wird zukünftig jede Maschine beinhalten, die durch den Anwender aufgebaut wurde, bis zu dessen Löschung. Die eindeutige Identifizierung jeder Maschine wird durch eine ID gelöst, die bei jedem Speichern einer Maschine fortlaufend hochgezählt wird.
Die Tabelle enthält zusätzlich zu der ID der Maschine, den Name, eine optionale Beschreibung (engl. Description), den aktuellen Status (Online/Offline) und die IP-Adresse der Maschine.\newline
Um den Anwender von Beginn an eine Auswahl an VM-Images anbieten zu können, werden in der Tabelle Image die vorgefertigten VM-Images abgelegt. Die Tabelle besteht aus den Attributen Name, das den Namen des Images beinhaltet und einer URL, die auf das Image im Web verweist.\newline
Die Tabelle \textbf{File} speichert Informationen zu Dateien und stellt diese in eine Relation zur virtuellen Maschine oder Softwarepaketen. Nicht nur der Name der Datei wird persistiert, sondern auch das Quellverzeichnis (engl. Source) und das Zielverzeichnis (engl. Target), das auf das Zielverzeichnis der virtuellen Maschine zeigt. Für die eindeutige Identifikation, bekommt jede Datei eine ID zugewiesen, die fortlaufend inkrementiert wird. Damit der VM-Builder in der Lage ist hochgeladene Dateien exakt wiederzuverwenden, werden in der Tabelle Option Eigenschaften wie das Kopieren oder Entpacken von Dateien hinterlegt. Jeder Datei, die im VM-Builder gespeichert wird, kann eine solche Eigenschaft zugewiesen werden, um ihr eindeutiges Verhalten zu definieren. Die Tabelle selbst besteht aus einer ID, durch die jede Option eindeutig identifiziert werden kann und dem Attribut Option, welches die Dateioptionen festlegt.\newline
Damit dem Anwender eine Softwareauswahl angeboten werden kann, wird die Tabelle \textbf{Software} benötigt. Jeder Eintrag besteht aus einer automatisch generierten, fortlaufenden SoftwareID, dem Namen der Software, einer optionalen Beschreibung (engl. Description) und der zwingend notwendigen Befehlszeile (engl. Command), die den Linux-Befehlt enthält, mit dem die Software installiert wird.\newline 
Die Abbildung \ref{fig:Entity-Relationship-Model} zeigt zusätzlich eine rekursive Eigenschaft der Tabelle Software. Die Rekursion entsteht durch die Funktion der Softwarepaketerstellung. Da jedes Softwarepaket aus mehreren Softwarekomponenten bestehen kann, ein Softwarepaket aber auch in der Liste der Softwarekomponenten geführt wird, entsteht so die Rekursion. Die genaue Umsetzung von rekursiven Tabellen wird im folgenden Abschnitt erklärt.
\pagebreak
\subsubsection{Relationales Datenbank Modell}\label{sssec:RelationalDatabaseModel}
\begin{figure}[htb]
  \centering
\includegraphics[width=0.9\textwidth]{../Bilder/RelationalDatabaseDiagram.png}
  \caption[RelationalDatabaseModel]{RelationalDatabaseModel\footnotemark}
	\label{fig:RelationalDatabaseModel}
\end{figure}\footnotetext{Bildquelle: Eigene Darstellung}
\FloatBarrier
Diese Darstellung konkretisiert den Datenbankentwurf aus dem Abschnitt \ref{sssec:ERM} durch eine detaillierte Ansicht der Tabellenkonstrukte und erleichtert die Implementierung der einzelnen Tabellenstrukturen. Dafür werden im weiteren Verlauf dieser Ausarbeitung Beziehungen zwischen Tabellen aufgelöst und ggf. neue Tabellen hinzugefügt. Zudem werden Primär- und Fremdschlüsselbeziehungen herausgestellt, um die Darstellung nah an die Implementierung zu bringen.\newline Ein Primärschlüssel wird immer aus einer Menge von Schlüsselkandidaten bestimmt, deren Definition in \cite{pernul2003datenbanken} lautet:
\begin{quote}
'Ist die identifizierte Attributmenge "minimal", d.h. ein Oberschlüssel, aus dem keine Attribute gestrichen werden können, ohne das die Schlüsseleigenschaften verloren gehen, so handelt es sich um einen Schlüsselkandidaten K.'
\end{quote}
Ein Fremdschlüssel zeichnet sich dadurch aus, dass dieser entweder ein Primärschlüssel oder ein Schlüsselkandidat aus einer anderen Tabelle ist.
Da das RDM (Relationales Datanbank Modell) nah an die reale Umsetzung angelehnt ist, erfordert es die Auflösung der Beziehungstypen aus dem vorherigen Abschnitt \ref{sssec:ERM}.\newline Die erste betrachtete Regel bezieht sich bei der Umwandlung auf N:M Beziehungen. Nach \cite{jarosch2002datenbankentwurf} müssen N:M Beziehungen in 1:N und N:1 Typen umgeformt werden, wodurch eine Zwischentabelle (Koppeltabelle) entsteht. Angewendet auf Abbildung \ref{fig:Entity-Relationship-Model} bedeutet das, dass neue Tabellen entstehen, die jeweils als Relation zwischen den folgenden Tabellen entstehen:
\begin{enumerate}
\item Software und Machine
\item Software und File
\item Machine und File
\item Software und Software
\end{enumerate} 
Die neu entstandenen Zwischentabellen nutzen die Primärschlüssel der Tabellen, die vorher N:M verknüpft waren, als Fremdschüssel und wandeln diesen in deren eigenen Primärschlüssel um. So werden beispielsweise die Tabellen Machine und Software mit der Zwischentabelle MachineSoftware verknüpft und die Umformung in eine 1:N und N:1 Beziehung durchgeführt. Dieses gilt auch für die Auflösung der Beziehungen zwischen den Tabellen Software und File und Machine und File.
Die vierte M:N Beziehung beinhaltet einen speziellen Faktor, der eine andere Herangehensweise benötigt. Die Besonderheit hier besteht in der Rekursion, die auf die eigene Tabelle zeigt und nach \cite{pernul2003datenbanken} wie folgt aufgelöst werden muss:
\begin{quote}
'Rekursive Beziehungstypen beschreiben eine Beziehung verschiedener Entities innerhalb eines einzigen Entitytypen. Durch diesen Sachverhalt stehen wir im Relationenmodell vor dem Problem, dass nach der Transformation die Attribute des Primärschlüssels nun zweimal auftauchen. Eine Forderung des rationalen Datenbankmodells ist aber die Eindeutigkeit von Attributbezeichnungen. Aus diesem Grund muss eine der beiden Bezeichnungen - in Anlehnung an die Art der Beziehung - umbenannt werden. [...] Bei einer Kardinalität {M:N} muss ein zusätzliches Relationenschema erstellt werden, dass als Attribut zumindest den Primärschlüssel und den umbenannten Primärschlüssel aus dem Entitytyp-Relationenschema enthält. In dem neuen Relationenschema bilden dann beide Attributmengen gemeinsam den Primärschlüssel.'
\end{quote}
Die Transformierung besagt, dass im ersten Schritt auch hier eine neue Tabelle entstehen muss. Da die Rekursion durch die Verwendung von Softwarepaketen entstanden ist, wird die neue Tabelle Package genannt. Im nächsten Schritt muss nach \cite{pernul2003datenbanken} die neue Tabelle Package den Primärschlüssel aus der Tabelle Software zwei Mal enthalten, wobei darauf zu achten ist, dass ein Schlüssel unbenannt werden muss. Das entspricht in diesem Fall der partID, wodurch die Umwandlung abgeschlossen ist.\newline\newline 
Für die letzte Transformation werden die 1:N Beziehungen betrachtet, die den folgenden Relationen entsprechen:
\begin{enumerate}
\item File und Option
\item Image und Machine
\end{enumerate}
Um auch hier die Umwandlung korrekt vorzunehmen, müssen folgende Regeln beachtet werden:
\begin{enumerate}
\item Relationen, die aus dem Entitätstyp mit Kardinalität 1 gebildet wurden, bleiben erhalten.
\item  Primärschlüssel aus der Relation mit Kardinalität 1 werden als Fremdschlüssel in die N-Relation eingesetzt.
\end{enumerate}
Als Beispiel für die Umsetzung der Regeln werden die Tabellen File und Option herangezogen. Der Primärschlüssel aus Tabelle Option wird in Tabelle File als Fremdschlüssel eingesetzt und wird so als ein Teil der Tabelle File. Da die Regeln besagen, dass die Tabelle mit der Kardinalität 1 unverändert bleibt, wird an der Tabelle Option keine weitere Veränderung vorgenommen.
\section{Client}\label{sec:Client}
Im Gegensatz zum Server benötigt der Client keine ausführliche Planung und Modellierung, da das angestrebte Konstrukt ein Thin-Client ist. Diese Art von Clients benötigt wenige oder keine Anwendungsteile auf dem Client-Rechner.
Auf Anwenderseite wird entsprechend nur die Weboberfläche des VM-Builders aufgerufen, damit die Funktionalitäten bereitstehen. Es wird keine lokale Datenbank oder andere Software zum Betrieb benötigt. So ist Logik, die der Client benötigt, auf dem Server verankert. Dieses gilt auch für die Darstellungen der angezeigten Webelemente. Diese werden durch die Views in den entsprechenden Komponenten der Benutzerschnittstelle realisiert und zur Verfügung gestellt.
Eine detaillierte Ansicht zu der Kommunikation zwischen Client und Server sowie deren Ablauf ist z.B. in der Laufzeitsicht (siehe Abschnitt \ref{ssec:Laufzeitsicht}) zu finden.

\section{Zusammenfassung}
Die einzelnen Phasen des Entwurfs ermöglichen nicht nur den Aufbau der Software besser zu verstehen, sondern ermöglichen auch eine definierte Strukturierung der Anwendung.
Die Kontextabgrenzung in Abschnitt \ref{sec:Kontextabgrenzung} zeigt den VM-Builder inklusive dessen Umsysteme, während die Verteilungssicht (siehe Abschnitt \ref{sec:Verteilungssicht}) weitere Details zu verwendeten Applikationen und deren Platzierung im VM-Builder darstellt.
Abschnitt \ref{sec:Systemarchitektur} beschreibt zwei Systemarchitekturen, die die Anwendung strukturieren und Zuständigkeiten definieren. Das erste Modell der Architektur ist das Client-Server-Modell, wodurch die Aufgabenverteilung zwischen Client und Server festgelegt wurde, während das MVC-Entwurfsmuster die Zuständigkeiten der einzelnen Schichten bestimmt.\\ Die darauf folgende Übersicht der Kommunikation geht exemplarisch auf das Verhalten von Sinatra ein und zeigt die Annahme von Clientaufrufen und den Aufbau von Routen (siehe Abschnitt \ref{sec:Kommunikation}).\\
Nachdem die Basis definiert wurde, befasst sich Abschnitt \ref{sec:Server} mit der Konzipierung der Serverseite unter der Verwendung der Bausteinsicht (Abschnitt \ref{ssec:Bausteinsicht}) und der Laufzeitsicht (Abschnitt \ref{ssec:Laufzeitsicht}).
Die Bausteinsicht zeigt die Komponenten der einzelnen Schichten, deren Verbindungen zu anderen Komponenten und Abhängigkeiten zu der darunter liegenden Schicht. Während die Komponenten in den Schichten noch als Blackboxen dargestellt sind, werden diese in den einzelnen Erklärungen als Whitebox gezeigt, um eine detailliertere Ansicht auf deren Aufbau und Kommunikation zu erhalten.
Die Wirkungsweise der Komponenten kann durch die Laufzeitsicht gezeigt werden, die exemplarisch Abläufe darstellt, um so die Aufgabenverteilung der involvierten Komponenten herauszustellen.
Abschnitt \ref{ssec:Datenbank} befasst sich mit dem konzeptionellen Entwurf des Datenbankschemas und dessen Umwandlung für die spätere Implementierung.
Im Abschnitt \ref{sec:Client} wird der Client beschrieben. Da es sich bei dem Client-Konstrukt um einen Thin-Client handelt, der ohne weitere lokale Software verwendbar ist, wird keine Planung des Clients benötigt.